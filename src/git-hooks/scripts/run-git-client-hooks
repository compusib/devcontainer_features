#!/bin/bash

# General git client hook dispatcher
# Executes all hooks in <hook-name>.d/ directory based on how it was invoked

set -e  # Exit on first error

# Function to find git root directory (same as in setup-git-hooks)
get_git_root() {
    local current_dir="${1:-$(pwd)}"
    local search_dir="$current_dir"
    
    # If we're inside a .git directory, move up until we're outside it
    while [[ "$search_dir" == *"/.git"* ]] && [ "$search_dir" != "/" ]; do
        search_dir="$(dirname "$search_dir")"
    done
    
    # First try git rev-parse --show-toplevel if git is available and we're not in .git
    if command -v git >/dev/null 2>&1; then
        local git_root
        git_root=$(cd "$search_dir" && git rev-parse --show-toplevel 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$git_root" ]; then
            echo "$git_root"
            return 0
        fi
    fi
    
    # Fallback: search for .git directory in parent paths
    while [ "$search_dir" != "/" ]; do
        if [ -d "$search_dir/.git" ] || [ -f "$search_dir/.git" ]; then
            echo "$search_dir"
            return 0
        fi
        search_dir="$(dirname "$search_dir")"
    done
    
    # No git repository found
    return 1
}

# Get the git repository root
GIT_ROOT=$(get_git_root)
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Not in a git repository"
    exit 1
fi

# Get the name this script was called with (the symlink name)
HOOK_NAME="$(basename "$0")"

# Look for hooks in the standard git/hooks directory
HOOKS_DIR="$GIT_ROOT/git/hooks/${HOOK_NAME}.d"

echo "üöÄ Running $HOOK_NAME hooks..."

# Check if hooks directory exists
if [ ! -d "$HOOKS_DIR" ]; then
    echo "‚ÑπÔ∏è  No ${HOOK_NAME}.d directory found, skipping hook execution"
    exit 0
fi

# Get all executable files in hooks directory, sorted numerically by filename
hooks=($(find "$HOOKS_DIR" -type f -executable | sort -V))

if [ ${#hooks[@]} -eq 0 ]; then
    echo "‚ÑπÔ∏è  No executable hooks found in ${HOOK_NAME}.d/"
    exit 0
fi

echo "üìã Found ${#hooks[@]} $HOOK_NAME hook(s) to execute:"
for hook in "${hooks[@]}"; do
    echo "  - $(basename "$hook")"
done
echo ""

# Execute each hook
hook_count=0
failed_hooks=0

for hook in "${hooks[@]}"; do
    hook_name=$(basename "$hook")
    hook_count=$((hook_count + 1))
    
    echo "[$hook_count/${#hooks[@]}] Executing $hook_name..."
    
    # Execute the hook with all arguments passed to this script
    if "$hook" "$@"; then
        echo "‚úÖ $hook_name completed successfully"
    else
        exit_code=$?
        echo "‚ùå $hook_name failed with exit code $exit_code"
        failed_hooks=$((failed_hooks + 1))
        exit $exit_code  # Exit immediately on first failure
    fi
    
    echo ""
done

# Summary
if [ $failed_hooks -eq 0 ]; then
    echo "üéâ All $HOOK_NAME hooks completed successfully!"
else
    echo "‚ùå $failed_hooks $HOOK_NAME hook(s) failed"
    exit 1
fi

exit 0
