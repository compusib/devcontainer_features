#!/bin/bash

get_git_root() {
    local current_dir="${1:-$(pwd)}"
    local search_dir="$current_dir"

    # If we're inside a .git directory, move up until we're outside it
    while [ "$search_dir" == *"/.git"* ] &&  "$search_dir" != "/" ; do
        search_dir="$(dirname "$search_dir")"
    done

    # First try git rev-parse --show-toplevel if git is available and we're not in .git
    if command -v git >/dev/null 2>&1; then
        local git_root
        git_root=$(cd "$search_dir" && git rev-parse --show-toplevel 2>/dev/null)
        if  [[ $? -eq 0 ]] && [[ -n "$git_root" ]]; then
            echo "$git_root"
            return 0
        fi
    fi

    # No git repository found
    return 1
}

# ARG_OPTIONAL_SINGLE([hooks-dir],[d],[Custom source directory for hooks],[git/hooks])
# ARG_OPTIONAL_SINGLE([target-dir],[t],[Custom target directory for git hooks],[.git/hooks])
# ARG_OPTIONAL_SINGLE([repo-dir],[r],[Custom git repository directory],["$(get_git_root .)"])
# ARG_OPTIONAL_BOOLEAN([dry-run],[n],[Show what would be done without making changes])
# ARG_OPTIONAL_BOOLEAN([force],[f],[Force overwrite existing hooks without prompting])
# ARG_OPTIONAL_BOOLEAN([list],[l],[List available hook types and exit])
# ARG_OPTIONAL_BOOLEAN([verbose],[v],[Enable verbose output])
# ARG_OPTIONAL_BOOLEAN([clean],[c],[Remove all installed hook symlinks])
# ARG_HELP([Git hooks setup script with argbash - installs project git hooks])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='dtrnflvch'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_hooks_dir="git/hooks"
_arg_target_dir=".git/hooks"
_arg_repo_dir="$(get_git_root .)"
_arg_dry_run="off"
_arg_force="off"
_arg_list="off"
_arg_verbose="off"
_arg_clean="off"


print_help()
{
	printf '%s\n' "Git hooks setup script with argbash - installs project git hooks"
	printf 'Usage: %s [-d|--hooks-dir <arg>] [-t|--target-dir <arg>] [-r|--repo-dir <arg>] [-n|--(no-)dry-run] [-f|--(no-)force] [-l|--(no-)list] [-v|--(no-)verbose] [-c|--(no-)clean] [-h|--help]\n' "$0"
	printf '\t%s\n' "-d, --hooks-dir: Custom source directory for hooks (default: 'git/hooks')"
	printf '\t%s\n' "-t, --target-dir: Custom target directory for git hooks (default: '.git/hooks')"
	printf '\t%s\n' "-r, --repo-dir: Custom git repository directory (default: '$(get_git_root .)')"
	printf '\t%s\n' "-n, --dry-run, --no-dry-run: Show what would be done without making changes (off by default)"
	printf '\t%s\n' "-f, --force, --no-force: Force overwrite existing hooks without prompting (off by default)"
	printf '\t%s\n' "-l, --list, --no-list: List available hook types and exit (off by default)"
	printf '\t%s\n' "-v, --verbose, --no-verbose: Enable verbose output (off by default)"
	printf '\t%s\n' "-c, --clean, --no-clean: Remove all installed hook symlinks (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--hooks-dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_hooks_dir="$2"
				shift
				;;
			--hooks-dir=*)
				_arg_hooks_dir="${_key##--hooks-dir=}"
				;;
			-d*)
				_arg_hooks_dir="${_key##-d}"
				;;
			-t|--target-dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_target_dir="$2"
				shift
				;;
			--target-dir=*)
				_arg_target_dir="${_key##--target-dir=}"
				;;
			-t*)
				_arg_target_dir="${_key##-t}"
				;;
			-r|--repo-dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_repo_dir="$2"
				shift
				;;
			--repo-dir=*)
				_arg_repo_dir="${_key##--repo-dir=}"
				;;
			-r*)
				_arg_repo_dir="${_key##-r}"
				;;
			-n|--no-dry-run|--dry-run)
				_arg_dry_run="on"
				test "${1:0:5}" = "--no-" && _arg_dry_run="off"
				;;
			-n*)
				_arg_dry_run="on"
				_next="${_key##-n}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-n" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-f|--no-force|--force)
				_arg_force="on"
				test "${1:0:5}" = "--no-" && _arg_force="off"
				;;
			-f*)
				_arg_force="on"
				_next="${_key##-f}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-f" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-l|--no-list|--list)
				_arg_list="on"
				test "${1:0:5}" = "--no-" && _arg_list="off"
				;;
			-l*)
				_arg_list="on"
				_next="${_key##-l}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-l" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-v|--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-v*)
				_arg_verbose="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-c|--no-clean|--clean)
				_arg_clean="on"
				test "${1:0:5}" = "--no-" && _arg_clean="off"
				;;
			-c*)
				_arg_clean="on"
				_next="${_key##-c}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
